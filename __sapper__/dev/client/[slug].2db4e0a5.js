import { S as SvelteComponentDev, i as init, s as safe_not_equal, e as element, t as text, a as space, c as claim_element, b as children, d as claim_text, f as detach, E as set_custom_element_data, h as add_location, j as insert, k as append, o as get_slot_changes, p as get_slot_context, q as transition_in, r as transition_out, F as set_style, G as add_render_callback, H as listen, I as add_resize_listener, B as group_outros, J as update_keyed_each, C as check_outros, K as onMount, l as create_slot, L as outro_and_destroy_block, M as tick, N as binding_callbacks, g as attr, w as set_data, O as validate_store, P as subscribe, m as mount_component, z as get_spread_update, u as destroy_component, x as empty, D as destroy_each, Q as bind, y as assign, R as add_flush_callback } from './chunk.6be85367.js';
import { w as writable } from './chunk.f344364d.js';
import { D as DCRenderer } from './chunk.fd9f3f8f.js';

let groupedDataComponentShortCodes = [];


function createViewDefinition(){
	const {subscribe, set, update} = writable(null);

	return {
		subscribe,
		set,

		// Parses the current view definition data components, constructing a nested array of grouped data components and
		// their children and then adding all the ungrouped data components to the top
		populate: (payload) => {
			viewDefinition.set(payload);

			let dataComponentsToRender, dataComponent, isGroupedItself, allDataComponents;
			dataComponentsToRender = [];

			allDataComponents = payload.DataComponents;

			for(let i=0; i< allDataComponents.length; i++){
				dataComponent = allDataComponents[i];

				if(dataComponent.DisplayTypeShortCode === 'GROUP'){

					[dataComponent, isGroupedItself] = parseGroupDataComponent(dataComponent, allDataComponents);

					if(isGroupedItself == true){
						dataComponentsToRender.push(dataComponent);
					}
						groupedDataComponentShortCodes.push(dataComponent.ShortCode);
				}
			}

			let ungroupedDataComponents = [];

			// now populate ungrouped
			for(let i=0; i< allDataComponents.length; i++) {
				dataComponent = allDataComponents[i];

				if(groupedDataComponentShortCodes.indexOf(dataComponent.ShortCode) == -1){
					ungroupedDataComponents.push(dataComponent);
				}
			}

			dataComponentsToRender = ungroupedDataComponents.concat(dataComponentsToRender);

			dataComponents.set(dataComponentsToRender);
		}
	}
}





///////////////////////////////
// helpers
///////////////////////////////


function parseGroupDataComponent(groupDataComponent, allDataComponents){
	let setting = groupDataComponent.Settings.reduce(function(a,b){
		if(a.Id === 'DATA_COMPONENTS'){
			return a;
		}
	});

	let dataComponent, groupedChildren, isGroupedItself, dontCare;
	groupedChildren = [];
	isGroupedItself = false;

	for(let i=0; i< allDataComponents.length; i++){
		dataComponent = allDataComponents[i];

		if(setting.Text.indexOf(dataComponent.ShortCode) !== -1){

			if(dataComponent.DisplayTypeShortCode === 'GROUP') {
				isGroupedItself = true;
				[dataComponent, dontCare] = parseGroupDataComponent(dataComponent, allDataComponents);
			}
			else{
				groupedDataComponentShortCodes.push(dataComponent.ShortCode);
			}

			groupedChildren.push(dataComponent);
		}
	}

	groupDataComponent.children = groupedChildren;

	return [groupDataComponent, isGroupedItself];
}

///////////////////////////////////////////////////////////
//
// exports
//
///////////////////////////////////////////////////////////


const dataComponents = writable([]);
const viewDefinition = createViewDefinition();

/* node_modules/@sveltejs/svelte-virtual-list/VirtualList.svelte generated by Svelte v3.6.7 */

const file = "node_modules/@sveltejs/svelte-virtual-list/VirtualList.svelte";

const get_default_slot_changes = ({ row, visible }) => ({ item: visible });
const get_default_slot_context = ({ row, visible }) => ({ item: row.data });

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.row = list[i];
	return child_ctx;
}

// (164:2) {#each visible as row (row.index)}
function create_each_block(key_1, ctx) {
	var svelte_virtual_list_row, t0, t1, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, get_default_slot_context);

	return {
		key: key_1,

		first: null,

		c: function create() {
			svelte_virtual_list_row = element("svelte-virtual-list-row");

			if (!default_slot) {
				t0 = text("Missing template");
			}

			if (default_slot) default_slot.c();
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			svelte_virtual_list_row = claim_element(nodes, "SVELTE-VIRTUAL-LIST-ROW", { class: true }, false);
			var svelte_virtual_list_row_nodes = children(svelte_virtual_list_row);

			if (!default_slot) {
				t0 = claim_text(svelte_virtual_list_row_nodes, "Missing template");
			}

			if (default_slot) default_slot.l(svelte_virtual_list_row_nodes);
			t1 = claim_text(svelte_virtual_list_row_nodes, "\n\t\t\t");
			svelte_virtual_list_row_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-1tqh76q");
			add_location(svelte_virtual_list_row, file, 164, 3, 3457);
			this.first = svelte_virtual_list_row;
		},

		m: function mount(target, anchor) {
			insert(target, svelte_virtual_list_row, anchor);

			if (!default_slot) {
				append(svelte_virtual_list_row, t0);
			}

			else {
				default_slot.m(svelte_virtual_list_row, null);
			}

			append(svelte_virtual_list_row, t1);
			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && (changed.$$scope || changed.visible)) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, get_default_slot_changes), get_slot_context(default_slot_1, ctx, get_default_slot_context));
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(svelte_virtual_list_row);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	var svelte_virtual_list_viewport, svelte_virtual_list_contents, each_blocks = [], each_1_lookup = new Map(), svelte_virtual_list_viewport_resize_listener, current, dispose;

	var each_value = ctx.visible;

	const get_key = ctx => ctx.row.index;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
			this.h();
		},

		l: function claim(nodes) {
			svelte_virtual_list_viewport = claim_element(nodes, "SVELTE-VIRTUAL-LIST-VIEWPORT", { style: true, class: true }, false);
			var svelte_virtual_list_viewport_nodes = children(svelte_virtual_list_viewport);

			svelte_virtual_list_contents = claim_element(svelte_virtual_list_viewport_nodes, "SVELTE-VIRTUAL-LIST-CONTENTS", { style: true, class: true }, false);
			var svelte_virtual_list_contents_nodes = children(svelte_virtual_list_contents);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(svelte_virtual_list_contents_nodes);

			svelte_virtual_list_contents_nodes.forEach(detach);
			svelte_virtual_list_viewport_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			set_style(svelte_virtual_list_contents, "padding-top", "" + ctx.top + "px");
			set_style(svelte_virtual_list_contents, "padding-bottom", "" + ctx.bottom + "px");
			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-1tqh76q");
			add_location(svelte_virtual_list_contents, file, 159, 1, 3301);
			add_render_callback(() => ctx.svelte_virtual_list_viewport_resize_handler.call(svelte_virtual_list_viewport));
			set_style(svelte_virtual_list_viewport, "height", ctx.height);
			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-1tqh76q");
			add_location(svelte_virtual_list_viewport, file, 153, 0, 3155);
			dispose = listen(svelte_virtual_list_viewport, "scroll", ctx.handle_scroll);
		},

		m: function mount(target, anchor) {
			insert(target, svelte_virtual_list_viewport, anchor);
			append(svelte_virtual_list_viewport, svelte_virtual_list_contents);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(svelte_virtual_list_contents, null);

			ctx.svelte_virtual_list_contents_binding(svelte_virtual_list_contents);
			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, ctx.svelte_virtual_list_viewport_resize_handler.bind(svelte_virtual_list_viewport));
			ctx.svelte_virtual_list_viewport_binding(svelte_virtual_list_viewport);
			current = true;
		},

		p: function update(changed, ctx) {
			const each_value = ctx.visible;

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block, null, get_each_context);
			check_outros();

			if (!current || changed.top) {
				set_style(svelte_virtual_list_contents, "padding-top", "" + ctx.top + "px");
			}

			if (!current || changed.bottom) {
				set_style(svelte_virtual_list_contents, "padding-bottom", "" + ctx.bottom + "px");
			}

			if (!current || changed.height) {
				set_style(svelte_virtual_list_viewport, "height", ctx.height);
			}
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(svelte_virtual_list_viewport);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();

			ctx.svelte_virtual_list_contents_binding(null);
			svelte_virtual_list_viewport_resize_listener.cancel();
			ctx.svelte_virtual_list_viewport_binding(null);
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	// props
	let { items, height = '100%', itemHeight } = $$props;

	// read-only, but visible to consumers via bind:start
	let { start = 0, end = 0 } = $$props;

	// local state
	let height_map = [];
	let rows;
	let viewport;
	let contents;
	let viewport_height = 0;
	let visible;
	let mounted;

	let top = 0;
	let bottom = 0;
	let average_height;

	async function refresh(items, viewport_height, itemHeight) {
		const { scrollTop } = viewport;

		await tick(); // wait until the DOM is up to date

		let content_height = top - scrollTop;
		let i = start;

		while (content_height < viewport_height && i < items.length) {
			let row = rows[i - start];

			if (!row) {
				$$invalidate('end', end = i + 1);
				await tick(); // render the newly visible row
				row = rows[i - start];
			}

			const row_height = height_map[i] = itemHeight || row.offsetHeight;
			content_height += row_height;			i += 1;
		}

		$$invalidate('end', end = i);

		const remaining = items.length - end;
		average_height = (top + content_height) / end;

		$$invalidate('bottom', bottom = remaining * average_height);
		height_map.length = items.length;
	}

	async function handle_scroll() {
		const { scrollTop } = viewport;

		const old_start = start;

		for (let v = 0; v < rows.length; v += 1) {
			height_map[start + v] = itemHeight || rows[v].offsetHeight;		}

		let i = 0;
		let y = 0;

		while (i < items.length) {
			const row_height = height_map[i] || average_height;
			if (y + row_height > scrollTop) {
				$$invalidate('start', start = i);
				$$invalidate('top', top = y);

				break;
			}

			y += row_height;
			i += 1;
		}

		while (i < items.length) {
			y += height_map[i] || average_height;
			i += 1;

			if (y > scrollTop + viewport_height) break;
		}

		$$invalidate('end', end = i);

		const remaining = items.length - end;
		average_height = y / end;

		while (i < items.length) { height_map[i++] = average_height; }
		$$invalidate('bottom', bottom = remaining * average_height);

		// prevent jumping if we scrolled up into unknown territory
		if (start < old_start) {
			await tick();

			let expected_height = 0;
			let actual_height = 0;

			for (let i = start; i < old_start; i +=1) {
				if (rows[i - start]) {
					expected_height += height_map[i];
					actual_height += itemHeight || rows[i - start].offsetHeight;
				}
			}

			const d = actual_height - expected_height;
			viewport.scrollTo(0, scrollTop + d);
		}

		// TODO if we overestimated the space these
		// rows would occupy we may need to add some
		// more. maybe we can just call handle_scroll again?
	}

	// trigger initial refresh
	onMount(() => {
		rows = contents.getElementsByTagName('svelte-virtual-list-row');
		$$invalidate('mounted', mounted = true);
	});

	const writable_props = ['items', 'height', 'itemHeight', 'start', 'end'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<VirtualList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function svelte_virtual_list_contents_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('contents', contents = $$value);
		});
	}

	function svelte_virtual_list_viewport_resize_handler() {
		viewport_height = this.offsetHeight;
		$$invalidate('viewport_height', viewport_height);
	}

	function svelte_virtual_list_viewport_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('viewport', viewport = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('items' in $$props) $$invalidate('items', items = $$props.items);
		if ('height' in $$props) $$invalidate('height', height = $$props.height);
		if ('itemHeight' in $$props) $$invalidate('itemHeight', itemHeight = $$props.itemHeight);
		if ('start' in $$props) $$invalidate('start', start = $$props.start);
		if ('end' in $$props) $$invalidate('end', end = $$props.end);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$$.update = ($$dirty = { items: 1, start: 1, end: 1, mounted: 1, viewport_height: 1, itemHeight: 1 }) => {
		if ($$dirty.items || $$dirty.start || $$dirty.end) { $$invalidate('visible', visible = items.slice(start, end).map((data, i) => {
				return { index: i + start, data };
			})); }
		if ($$dirty.mounted || $$dirty.items || $$dirty.viewport_height || $$dirty.itemHeight) { if (mounted) refresh(items, viewport_height, itemHeight); }
	};

	return {
		items,
		height,
		itemHeight,
		start,
		end,
		viewport,
		contents,
		viewport_height,
		visible,
		top,
		bottom,
		handle_scroll,
		svelte_virtual_list_contents_binding,
		svelte_virtual_list_viewport_resize_handler,
		svelte_virtual_list_viewport_binding,
		$$slots,
		$$scope
	};
}

class VirtualList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["items", "height", "itemHeight", "start", "end"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.items === undefined && !('items' in props)) {
			console.warn("<VirtualList> was created without expected prop 'items'");
		}
		if (ctx.itemHeight === undefined && !('itemHeight' in props)) {
			console.warn("<VirtualList> was created without expected prop 'itemHeight'");
		}
	}

	get items() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHeight() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHeight(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get start() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set start(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get end() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set end(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/view/[slug].svelte generated by Svelte v3.6.7 */

const file$1 = "src/routes/view/[slug].svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.item = list[i];
	return child_ctx;
}

// (55:3) {:else}
function create_else_block(ctx) {
	var each_1_anchor, current;

	var each_value = ctx.$dataComponents;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c: function create() {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.$dataComponents) {
				each_value = ctx.$dataComponents;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) out(i);
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

// (47:3) {#if $viewDefinition.UseVirtualList}
function create_if_block(ctx) {
	var div, updating_start, updating_end, t0, p, t1, t2, t3, t4, current;

	function virtuallist_start_binding(value) {
		ctx.virtuallist_start_binding.call(null, value);
		updating_start = true;
		add_flush_callback(() => updating_start = false);
	}

	function virtuallist_end_binding(value_1) {
		ctx.virtuallist_end_binding.call(null, value_1);
		updating_end = true;
		add_flush_callback(() => updating_end = false);
	}

	let virtuallist_props = {
		items: ctx.$dataComponents,
		$$slots: {
		default: [create_default_slot, ({ item }) => ({ item })]
	},
		$$scope: { ctx }
	};
	if (start !== void 0) {
		virtuallist_props.start = start;
	}
	if (end !== void 0) {
		virtuallist_props.end = end;
	}
	var virtuallist = new VirtualList({ props: virtuallist_props, $$inline: true });

	binding_callbacks.push(() => bind(virtuallist, 'start', virtuallist_start_binding));
	binding_callbacks.push(() => bind(virtuallist, 'end', virtuallist_end_binding));

	return {
		c: function create() {
			div = element("div");
			virtuallist.$$.fragment.c();
			t0 = space();
			p = element("p");
			t1 = text("showing items ");
			t2 = text(start);
			t3 = text("-");
			t4 = text(end);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			virtuallist.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach);
			t0 = claim_text(nodes, "\n\n\t\t\t\t");

			p = claim_element(nodes, "P", {}, false);
			var p_nodes = children(p);

			t1 = claim_text(p_nodes, "showing items ");
			t2 = claim_text(p_nodes, start);
			t3 = claim_text(p_nodes, "-");
			t4 = claim_text(p_nodes, end);
			p_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div, "class", "view-container svelte-1om8m3b");
			add_location(div, file$1, 47, 4, 1010);
			add_location(p, file$1, 53, 4, 1177);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(virtuallist, div, null);
			insert(target, t0, anchor);
			insert(target, p, anchor);
			append(p, t1);
			append(p, t2);
			append(p, t3);
			append(p, t4);
			current = true;
		},

		p: function update(changed, ctx) {
			var virtuallist_changes = {};
			if (changed.$dataComponents) virtuallist_changes.items = ctx.$dataComponents;
			if (changed.$$scope) virtuallist_changes.$$scope = { changed, ctx };
			if (!updating_start && changed.start) {
				virtuallist_changes.start = start;
			}
			if (!updating_end && changed.end) {
				virtuallist_changes.end = end;
			}
			virtuallist.$set(virtuallist_changes);

			if (!current || changed.start) {
				set_data(t2, start);
			}

			if (!current || changed.end) {
				set_data(t4, end);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(virtuallist.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(virtuallist.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(virtuallist, );

			if (detaching) {
				detach(t0);
				detach(p);
			}
		}
	};
}

// (56:4) {#each $dataComponents as item}
function create_each_block$1(ctx) {
	var current;

	var dcrenderer_spread_levels = [
		ctx.item
	];

	let dcrenderer_props = {};
	for (var i = 0; i < dcrenderer_spread_levels.length; i += 1) {
		dcrenderer_props = assign(dcrenderer_props, dcrenderer_spread_levels[i]);
	}
	var dcrenderer = new DCRenderer({ props: dcrenderer_props, $$inline: true });

	return {
		c: function create() {
			dcrenderer.$$.fragment.c();
		},

		l: function claim(nodes) {
			dcrenderer.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(dcrenderer, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var dcrenderer_changes = changed.$dataComponents ? get_spread_update(dcrenderer_spread_levels, [
				ctx.item
			]) : {};
			dcrenderer.$set(dcrenderer_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(dcrenderer.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(dcrenderer.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(dcrenderer, detaching);
		}
	};
}

// (49:5) <VirtualList items={$dataComponents} let:item bind:start bind:end>
function create_default_slot(ctx) {
	var current;

	var dcrenderer_spread_levels = [
		ctx.item
	];

	let dcrenderer_props = {};
	for (var i = 0; i < dcrenderer_spread_levels.length; i += 1) {
		dcrenderer_props = assign(dcrenderer_props, dcrenderer_spread_levels[i]);
	}
	var dcrenderer = new DCRenderer({ props: dcrenderer_props, $$inline: true });

	return {
		c: function create() {
			dcrenderer.$$.fragment.c();
		},

		l: function claim(nodes) {
			dcrenderer.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(dcrenderer, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var dcrenderer_changes = changed.item ? get_spread_update(dcrenderer_spread_levels, [
				ctx.item
			]) : {};
			dcrenderer.$set(dcrenderer_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(dcrenderer.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(dcrenderer.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(dcrenderer, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	var t0, form, header, h1, t1_value = ctx.$viewDefinition.ScreenName, t1, t2, p, t3_value = ctx.$viewDefinition.ScreenHelpDescription, t3, t4, fieldset, legend, t5_value = ctx.$viewDefinition.ScreenName, t5, t6, current_block_type_index, if_block, current;

	var if_block_creators = [
		create_if_block,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.$viewDefinition.UseVirtualList) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			t0 = space();
			form = element("form");
			header = element("header");
			h1 = element("h1");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			fieldset = element("fieldset");
			legend = element("legend");
			t5 = text(t5_value);
			t6 = space();
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "\n\n");

			form = claim_element(nodes, "FORM", { autocomplete: true }, false);
			var form_nodes = children(form);

			header = claim_element(form_nodes, "HEADER", {}, false);
			var header_nodes = children(header);

			h1 = claim_element(header_nodes, "H1", {}, false);
			var h1_nodes = children(h1);

			t1 = claim_text(h1_nodes, t1_value);
			h1_nodes.forEach(detach);
			t2 = claim_text(header_nodes, "\n\n\t\t");

			p = claim_element(header_nodes, "P", {}, false);
			var p_nodes = children(p);

			t3 = claim_text(p_nodes, t3_value);
			p_nodes.forEach(detach);
			header_nodes.forEach(detach);
			t4 = claim_text(form_nodes, "\n\n\t");

			fieldset = claim_element(form_nodes, "FIELDSET", { class: true }, false);
			var fieldset_nodes = children(fieldset);

			legend = claim_element(fieldset_nodes, "LEGEND", { class: true }, false);
			var legend_nodes = children(legend);

			t5 = claim_text(legend_nodes, t5_value);
			legend_nodes.forEach(detach);
			t6 = claim_text(fieldset_nodes, "\n\t\t\t");
			if_block.l(fieldset_nodes);
			fieldset_nodes.forEach(detach);
			form_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			document.title = "View";
			add_location(h1, file$1, 39, 2, 806);
			add_location(p, file$1, 41, 2, 847);
			add_location(header, file$1, 38, 1, 795);
			attr(legend, "class", "svelte-1om8m3b");
			add_location(legend, file$1, 45, 2, 920);
			attr(fieldset, "class", "svelte-1om8m3b");
			add_location(fieldset, file$1, 44, 1, 907);
			attr(form, "autocomplete", "off");
			add_location(form, file$1, 37, 0, 768);
		},

		m: function mount(target, anchor) {
			insert(target, t0, anchor);
			insert(target, form, anchor);
			append(form, header);
			append(header, h1);
			append(h1, t1);
			append(header, t2);
			append(header, p);
			append(p, t3);
			append(form, t4);
			append(form, fieldset);
			append(fieldset, legend);
			append(legend, t5);
			append(fieldset, t6);
			if_blocks[current_block_type_index].m(fieldset, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.$viewDefinition) && t1_value !== (t1_value = ctx.$viewDefinition.ScreenName)) {
				set_data(t1, t1_value);
			}

			if ((!current || changed.$viewDefinition) && t3_value !== (t3_value = ctx.$viewDefinition.ScreenHelpDescription)) {
				set_data(t3, t3_value);
			}

			if ((!current || changed.$viewDefinition) && t5_value !== (t5_value = ctx.$viewDefinition.ScreenName)) {
				set_data(t5, t5_value);
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(fieldset, null);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t0);
				detach(form);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}




// loading the url from the slug (route param)
async function preload({ params, query }) {
	// the `slug` parameter is available because
	// this file is called [slug].svelte


	const res = await this.fetch(`${params.slug.replace(/[|-]/g, '/')}`);
	const data = await res.json();

	if (res.status === 200) {
		viewDefinition.populate(data);
	} else {
		this.error(res.status, data.message);
	}
}



let start;
let end;

function instance$1($$self, $$props, $$invalidate) {
	let $viewDefinition, $dataComponents;

	validate_store(viewDefinition, 'viewDefinition');
	subscribe($$self, viewDefinition, $$value => { $viewDefinition = $$value; $$invalidate('$viewDefinition', $viewDefinition); });
	validate_store(dataComponents, 'dataComponents');
	subscribe($$self, dataComponents, $$value => { $dataComponents = $$value; $$invalidate('$dataComponents', $dataComponents); });

	function virtuallist_start_binding(value) {
		start = value;
		$$invalidate('start', start);
	}

	function virtuallist_end_binding(value_1) {
		end = value_1;
		$$invalidate('end', end);
	}

	return {
		$viewDefinition,
		$dataComponents,
		virtuallist_start_binding,
		virtuallist_end_binding
	};
}

class Slug extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
	}
}

export default Slug;
export { preload };
